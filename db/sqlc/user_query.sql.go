// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user_query.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createUser = `-- name: CreateUser :exec
INSERT INTO user (
    user_id,
    email,
    password
) VALUES (
    ?, ?, ?
)
`

type CreateUserParams struct {
	UserID   []byte
	Email    string
	Password string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.ExecContext(ctx, createUser, arg.UserID, arg.Email, arg.Password)
	return err
}

const deleteUserById = `-- name: DeleteUserById :exec
DELETE FROM user
WHERE user_id = ?
`

func (q *Queries) DeleteUserById(ctx context.Context, userID []byte) error {
	_, err := q.db.ExecContext(ctx, deleteUserById, userID)
	return err
}

const findUserByEmail = `-- name: FindUserByEmail :one
SELECT
    user_id, email, password
FROM 
    user
WHERE
    email = ?
LIMIT 1
`

func (q *Queries) FindUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, findUserByEmail, email)
	var i User
	err := row.Scan(&i.UserID, &i.Email, &i.Password)
	return i, err
}

const findUserById = `-- name: FindUserById :one
SELECT
    user_id, email, password
FROM 
    user
WHERE
    user_id = ?
LIMIT 1
`

func (q *Queries) FindUserById(ctx context.Context, userID []byte) (User, error) {
	row := q.db.QueryRowContext(ctx, findUserById, userID)
	var i User
	err := row.Scan(&i.UserID, &i.Email, &i.Password)
	return i, err
}

const findUserByIdWithReferences = `-- name: FindUserByIdWithReferences :many
SELECT
    u.user_id, u.email, u.password,
    e.event_id, e.user_id, e.name, e.description, e.location, e.date_time
FROM
    user u
LEFT JOIN
    event e
ON u.user_id = e.user_id
WHERE
    1 = 1
    AND u.user_id = ?
`

type FindUserByIdWithReferencesRow struct {
	UserID      []byte
	Email       string
	Password    string
	EventID     sql.NullString
	UserID_2    sql.NullString
	Name        sql.NullString
	Description sql.NullString
	Location    sql.NullString
	DateTime    sql.NullTime
}

func (q *Queries) FindUserByIdWithReferences(ctx context.Context, userID []byte) ([]FindUserByIdWithReferencesRow, error) {
	rows, err := q.db.QueryContext(ctx, findUserByIdWithReferences, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindUserByIdWithReferencesRow
	for rows.Next() {
		var i FindUserByIdWithReferencesRow
		if err := rows.Scan(
			&i.UserID,
			&i.Email,
			&i.Password,
			&i.EventID,
			&i.UserID_2,
			&i.Name,
			&i.Description,
			&i.Location,
			&i.DateTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userExistsByEmail = `-- name: UserExistsByEmail :one
SELECT EXISTS (
    SELECT 1 FROM user WHERE email = ?
)
`

func (q *Queries) UserExistsByEmail(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRowContext(ctx, userExistsByEmail, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
